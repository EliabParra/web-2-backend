import { Database } from './db.js'
import fs from 'node:fs/promises'
import path from 'path'
import colors from 'colors'

interface TableInfo {
    table_schema: string
    table_name: string
}

interface ColumnInfo {
    column_name: string
    data_type: string
    is_nullable: string
    column_default: string | null
}

/**
 * Introspector class - Reads database schema and generates TypeScript files.
 * Implements "DB -> Code" synchronization.
 */
export class Introspector {
    constructor(
        private db: Database,
        private outputDir: string
    ) {}

    /**
     * Lists all user tables in the database (excludes system schemas).
     */
    async listTables(): Promise<TableInfo[]> {
        const result = await this.db.exeRaw(`
            SELECT table_schema, table_name 
            FROM information_schema.tables 
            WHERE table_type = 'BASE TABLE'
              AND table_schema NOT IN ('pg_catalog', 'information_schema')
            ORDER BY table_schema, table_name
        `)
        return result.rows as TableInfo[]
    }

    /**
     * Gets column definitions for a specific table.
     */
    async getColumns(schema: string, table: string): Promise<ColumnInfo[]> {
        const result = await this.db.exeRaw(
            `
            SELECT column_name, data_type, is_nullable, column_default
            FROM information_schema.columns
            WHERE table_schema = $1 AND table_name = $2
            ORDER BY ordinal_position
        `,
            [schema, table]
        )
        return result.rows as ColumnInfo[]
    }

    /**
     * Generates a CREATE TABLE statement from column info.
     */
    private generateCreateTable(schema: string, table: string, columns: ColumnInfo[]): string {
        const colDefs = columns
            .map((col) => {
                let def = `        ${col.column_name} ${col.data_type}`
                if (col.is_nullable === 'NO') def += ' not null'
                if (col.column_default) def += ` default ${col.column_default}`
                return def
            })
            .join(',\n')

        return `create table if not exists ${schema}.${table} (\n${colDefs}\n    );`
    }

    /**
     * Generates a TypeScript schema file for a table.
     */
    /**
     * Introspects the entire database and generates schema files.
     * Skips tables that are already defined in local files.
     */
    /**
     * Scans the output directory for existing table definitions in .ts files.
     * Returns a Map of "schema.table" -> "filename".
     */
    async scanExistingSchemas(): Promise<Map<string, string>> {
        const existingTables = new Map<string, string>()

        try {
            const files = await fs.readdir(this.outputDir)
            for (const file of files) {
                if (!file.endsWith('.ts')) continue

                const filePath = path.join(this.outputDir, file)
                const content = await fs.readFile(filePath, 'utf-8')

                const regex =
                    /create\s+table\s+(?:if\s+not\s+exists\s+)?([a-zA-Z0-9_]+)\.([a-zA-Z0-9_]+)/gi
                let match
                while ((match = regex.exec(content)) !== null) {
                    const schema = match[1].toLowerCase()
                    const table = match[2].toLowerCase()
                    existingTables.set(`${schema}.${table}`, file)
                }
            }
        } catch (e) {
            console.warn('‚ö†Ô∏è  Could not scan existing schemas:', e)
        }

        return existingTables
    }

    /**
     * Introspects the entire database and generates schema files.
     * Skips tables that are already defined in MANUALLY managed files.
     * Updates tables that are in AUTO-GENERATED files.
     */
    async introspectAll(options: { withData?: boolean } = {}): Promise<string[]> {
        console.log('\nüîç Introspecting database...'.cyan)

        const tables = await this.listTables()
        const existingTables = await this.scanExistingSchemas()

        console.log(`üìä Found ${tables.length} tables in DB.`.gray)
        console.log(`üìÇ Found ${existingTables.size} tables already defined in code.`.gray)

        const generatedFiles: string[] = []

        for (const table of tables) {
            const key = `${table.table_schema}.${table.table_name}`.toLowerCase()
            const existingFile = existingTables.get(key)
            let shouldProcess = true

            // If table exists, check if we should update it
            if (existingFile) {
                // Heuristic: Only update if it looks auto-generated
                // Standard: 80-89 are auto-generated.
                // Legacy support: 'auto_' prefix.
                const isAutoGenerated = /^(8[0-9]_|auto_)/.test(existingFile)

                if (!isAutoGenerated) {
                    // Start manually managed file -> Skip overwriting schema
                    shouldProcess = false

                    // CHANGE: If we want data, we might still need to generate a data-only file
                    if (options.withData) {
                        const data = await this.getData(table.table_schema, table.table_name)
                        if (data.length > 0) {
                            console.log(
                                `      üìù Found ${data.length} records in ${table.table_name} (Manual Table)`
                                    .gray
                            )
                            const priority = this.getTablePriority(table.table_name)
                            const dataContent = this.generateDataFile(
                                table.table_schema,
                                table.table_name,
                                data
                            )
                            const dataFilename = `90_data_${priority}_${table.table_schema}_${table.table_name}.ts`
                            const dataFilepath = path.join(this.outputDir, dataFilename)

                            await fs.writeFile(dataFilepath, dataContent, 'utf-8')
                            console.log(`   ‚úÖ Generated Data: ${dataFilename}`.green)
                            generatedFiles.push(dataFilepath)
                        }
                    }
                }
            }

            if (!shouldProcess) continue

            const columns = await this.getColumns(table.table_schema, table.table_name)
            let indexes: string[] = []
            let data: string[] = []

            indexes = await this.getIndexes(table.table_schema, table.table_name)

            if (options.withData) {
                data = await this.getData(table.table_schema, table.table_name)
                if (data.length > 0) {
                    console.log(`      üìù Found ${data.length} records in ${table.table_name}`.gray)
                }
            }

            const content = this.generateSchemaFile(
                table.table_schema,
                table.table_name,
                columns,
                indexes,
                data
            )

            // Determine filename: Use existing if available, else new standardized name
            const filename = existingFile || `80_${table.table_schema}_${table.table_name}.ts`
            const filepath = path.join(this.outputDir, filename)

            await fs.writeFile(filepath, content, 'utf-8')
            const statusIcon = existingFile ? 'üîÑ Updated' : '‚úÖ Generated'
            console.log(`   ${statusIcon}: ${filename}`.green)
            generatedFiles.push(filepath)
        }

        console.log(`\nüéâ Processed ${generatedFiles.length} schema files.`.green.bold)
        return generatedFiles
    }

    /**
     * Gets indexes for a specific table.
     */
    async getIndexes(schema: string, table: string): Promise<string[]> {
        const result = await this.db.exeRaw(
            `
            SELECT indexdef
            FROM pg_indexes
            WHERE schemaname = $1 AND tablename = $2
            ORDER BY indexname
        `,
            [schema, table]
        )
        return result.rows.map((r: any) => r.indexdef + ';')
    }

    /**
     * Gets all data rows formatted as INSERT statements.
     */
    async getData(schema: string, table: string): Promise<string[]> {
        // Warning: This could be heavy for large tables.
        // For introspection, we assume relatively small config/seed tables.
        const result = await this.db.exeRaw(`SELECT * FROM ${schema}.${table}`)

        if (result.rows.length === 0) return []

        const columns = Object.keys(result.rows[0])
        const pk = await this.getPrimaryKey(schema, table)
        const inserts: string[] = []

        for (const row of result.rows) {
            const values = columns.map((col) => this.formatValue(row[col]))

            let sql = `INSERT INTO ${schema}.${table} (${columns.join(', ')}) VALUES (${values.join(', ')})`

            // Add ON CONFLICT if we have a PK
            if (pk.length > 0) {
                const pkString = pk.join(', ')
                const updates = columns
                    .filter((col) => !pk.includes(col))
                    .map((col) => `${col} = EXCLUDED.${col}`)
                    .join(', ')

                sql += ` ON CONFLICT (${pkString}) DO UPDATE SET ${updates || `${pk[0]} = EXCLUDED.${pk[0]}`};`
            } else {
                sql += ';'
            }

            inserts.push(sql)
        }

        return inserts
    }

    /**
     * Gets the primary key column names for a table.
     */
    async getPrimaryKey(schema: string, table: string): Promise<string[]> {
        const result = await this.db.exeRaw(
            `
            SELECT a.attname
            FROM   pg_index i
            JOIN   pg_attribute a ON a.attrelid = i.indrelid
                                AND a.attnum = ANY(i.indkey)
            WHERE  i.indrelid = $1::regclass
            AND    i.indisprimary
            `,
            [`${schema}.${table}`]
        )
        return result.rows.map((r) => r.attname)
    }

    /**
     * Formats a JS value into a SQL literal.
     * Use with caution, strictly for introspection purposes.
     */
    private formatValue(val: unknown): string {
        if (val === null || val === undefined) return 'NULL'
        if (typeof val === 'number') return String(val)
        if (typeof val === 'boolean') return val ? 'TRUE' : 'FALSE'
        if (val instanceof Date) return `'${val.toISOString()}'`

        // Escape single quotes for strings/objects
        let str = String(val)
        if (typeof val === 'object') str = JSON.stringify(val)

        return `'${str.replace(/'/g, "''")}'`
    }

    /**
     * Generates a TypeScript schema file.
     */
    generateSchemaFile(
        schema: string,
        table: string,
        columns: ColumnInfo[],
        indexes: string[] = [],
        data: string[] = []
    ): string {
        const createSql = this.generateCreateTable(schema, table, columns)
        const constName = `${table.toUpperCase()}_SCHEMA`

        const parts = ['    // Table Definition', `    \`${createSql}\`,`]

        if (data.length > 0) {
            parts.push('\n    // Data Seeding')
            data.forEach((row) => parts.push(`    \`${row}\`, `))
        }

        if (indexes.length > 0) {
            parts.push('\n    // Indexes')
            indexes.forEach((idx) => parts.push(`    \`${idx}\`, `))
        }

        return `/**
 * Auto-generated schema for ${schema}.${table}
 * Generated at: ${new Date().toISOString()}
 */
export const ${constName} = [
${parts.join('\n')}
]
`
    }

    /**
     * Generates a TypeScript data-only file.
     */
    generateDataFile(schema: string, table: string, data: string[]): string {
        const constName = `DATA_${table.toUpperCase()}_SCHEMA`
        const parts = data.map((row) => `    \`${row}\`,`)

        return `/**
 * Auto-generated data for ${schema}.${table}
 * Generated at: ${new Date().toISOString()}
 */
export const ${constName} = [
${parts.join('\n')}
]
`
    }

    /**
     * Returns a sort priority for data files based on dependencies.
     * Lower number = Earlier execution.
     */
    private getTablePriority(tableName: string): string {
        const priorities: Record<string, string> = {
            // Level 1: Independent
            profiles: '010',
            objects: '020',

            // Level 2: Depend on Level 1
            users: '100', // depends on profiles
            methods: '110', // depends on objects

            // Level 3: Depend on Level 2
            user_profiles: '200', // depends on users, profiles
            user_devices: '210', // depends on users
            permission_methods: '220', // depends on methods, roles(profiles)
            sessions: '230', // depends on users
            audit_logs: '240', // depends on users
        }

        return priorities[tableName] || '999'
    }

    /**
     * Detects tables that exist in DB but not in code (schema drift).
     */
    async detectNewTables(knownTables: string[]): Promise<TableInfo[]> {
        const allTables = await this.listTables()
        const knownSet = new Set(knownTables.map((t) => t.toLowerCase()))

        return allTables.filter(
            (t) => !knownSet.has(`${t.table_schema}.${t.table_name}`.toLowerCase())
        )
    }
}
