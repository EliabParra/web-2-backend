# Internationalization System (i18n)

Your application speaks English, Spanish, and whatever languages you want to add.

## Modern Approach: Messages.ts per BO

Each Business Object has its own **typed TypeScript messages file**.

**AuthMessages.ts**

````typescript
export const AuthMessages = {
    es: {
        loginSuccess: 'Sesión iniciada exitosamente',
        registerSuccess: 'Usuario registrado exitosamente',
        validation: {
            emailRequired: 'El email es requerido',
            passwordTooShort: 'La contraseña debe tener al menos 8 caracteres',
        },
        welcomeBack: 'Bienvenido de nuevo, {name}',
    },
    en: {
        loginSuccess: 'Login successful',
        registerSuccess: 'User registered successfully',
        validation: {
            emailRequired: 'Email is required',
            passwordTooShort: 'Password must be at least 8 characters',
        },
        welcomeBack: 'Welcome back, {name}',
    },
}

## Usage
Keys are defined in `src/locales/es.ts`. The `I18nService` offers both typed and dynamic methods:

### 1. Typed Access (Recommended)
For use within Business Objects or components where the message set is known:
```typescript
// In your BO
const msg = this.i18n.messages.alerts.email; // Autocompleted!
````

### 2. Dynamic Access (Validation / Zod)

For cases where the key comes from dynamic validation or DB:

```typescript
// Translates a key (now with TxKey autocomplete)
const errorMsg = this.i18n.translate('alerts.invalidTx')
```

### 3. Interpolation

Automatic with `translate` or manual with `format`:

```typescript
this.i18n.translate('welcome', { name: 'Eliab' })
```

### 4. Date and Currency Formatting (Intl)

Use the native service methods that respect the current locale:

```typescript
this.i18n.formatDate(new Date()) // 2/2/2026
this.i18n.formatCurrency(100, 'USD') // $100.00
```

## Usage in Business Objects

### 1. `this.m` Accessor (Recommended)

Use the typed getter `this.m` to access messages in the current locale.

```typescript
import { AuthMessages } from './AuthMessages.js'

export class AuthBO extends BaseBO {
    private get m() {
        return this.i18n.use(AuthMessages)
    }

    async register(params: RegisterInput): Promise<ApiResponse> {
        // ...
        return this.created(null, this.m.registerSuccess) // ← Typed with autocompletion
    }
}
```

### 2. Interpolation (Variables)

Use `{variable}` in the string and `i18n.format()` to interpolate.

```typescript
const msg = this.i18n.format(this.m.welcomeBack, { name: 'Eliab' })
// "Welcome back, Eliab"
```

## Global Messages (Errors, Success, Alerts)

For general application messages (server errors, common alerts), use `this.i18n.messages`. This replaces the deprecated `i18n.get('string')` usage.

```typescript
// 100% typed access to global messages
const error = this.i18n.messages.errors.client.invalidParameters

// Usage in controllers
res.status(error.code).send(error)
```

## i18n Keys in Zod Schemas

Zod schemas use **translation keys** (strings) that are resolved at runtime.

```typescript
// AuthSchemas.ts
export const AuthSchemas = {
    login: z.object({
        email: z.string().email('bo.auth.validation.emailInvalid'),
        password: z.string().min(8, 'bo.auth.validation.passwordTooShort'),
    }),
}
```

The `BaseBO.validate()` takes these keys and calls `this.t(key)` internally, returning the message in the correct language.

> [!NOTE]
> Keys follow the pattern `bo.{boName}.validation.{field}{Error}`.

## How does the system know which language to use?

The language is defined at 3 priority levels:

1. **Environment Variable (`APP_LANG`)**: The server's default language (e.g., `es`).
2. **User Configuration**: (Future) Could load language from the user profile `users.language`.

The `i18n.use()` service automatically selects the correct message object based on `currentLocale`.
